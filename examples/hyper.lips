;; -*- scheme -*-

(define h (. hyperapp "h"))
(define app (. hyperapp "app"))

(define log (. console "log"))

(define-macro (--> expr . code)
  "Helper macro similar to -> that works well with jQuery chaining
   where method call look function invocation.

           usage: (--> ($ \"body\")
                       (css \"color\" \"red\")
                       (on \"click\" (lambda () (print \"click\"))))"
  (let ((obj (gensym)))
    `(let ((,obj ,expr))
       ,@(let ((result '()))
           (while code
             (let ((lst `(set! ,obj (apply (. ,obj ,(. (caar code) "name"))
                                           (list ,@(cdar code))))))
               (append! result lst))
             (set! code (cdr code)))
           (append! result obj)
           result))))

(define (dir obj)
  "(dir obj)

   Function return all props on the object including those in prototype chain."
  (if (null? obj) nil
      (append (array->list ((. Object "getOwnPropertyNames") (unbind obj)))
              (dir ((. Object "getPrototypeOf") (unbind obj))))))

(define (symbol->string s)
  "(symbol->string symbol)

   Function convert LIPS symbol to string."
  (and (symbol? s) (. s "name")))

(define (string->symbol string)
  "(string->symbol string)

   Function convert string to LIPS symbol."
  (and (string? string) (new (. lips "Symbol") string)))

(define key-list '(:foo 10 :bar 20))

(define (value obj)
  "(value obj)

   Function unwrap LNumbers and convert nil value to undefined."
  (if (eq? obj nil)
      undefined
      (if (number? obj)
          ((. obj "valueOf"))
          obj)))

(define (substring string start end)
  "(substring string start [end])

   Function return part of the string that start with start index
   and end in end index, if end is undfined it return to the end."
  ((. string "substring") (value start) (value end)))


(define (concat . args)
  "(concat . strings)

   Function create new string by joining its arguments"
  ((. (list->array args) "join") ""))

(define (key? symbol)
  "(key? symbol)

   Function check if symbol is key symbol, have colon as first character."
  (and (symbol? symbol) (eq? ":" (substring (symbol->string symbol) 0 1))))

(define (key->string symbol)
  "(key->string symbol)

   If symbol is key it convert that to string - remove colon."
  (if (key? symbol)
      (substring (symbol->string symbol) 1)))

(define (alist->object alist)
  "(alist->object alist)

   Function convert alist pairs to JavaScript object."
  (if (pair? alist)
      ((. alist "toObject"))))

(define (pair-map fn seq-list)
  "(seq-map fn list)

   Function call fn argument for pairs in a list and return combined list with
   values returned from function fn. It work like the map but take two items from list"
  (let iter ((seq-list seq-list) (result '()))
    (if (null? seq-list)
        result
        (if (and (pair? seq-list) (pair? (cdr seq-list)))
            (let* ((first (car seq-list))
                   (second (cadr seq-list))
                   (value (fn first second)))
              (if (null? value)
                  (iter (cddr seq-list) result)
                  (iter (cddr seq-list) (cons value result))))))))


(define (klist->alist klist)
  "(klist->alist klist)

   Function convert klist in form (:foo 10 :bar 20) into alist
   in form ((foo . 10) (bar . 20))."
  (pair-map (lambda (first second)
              (if (key? first)
                  (cons (key->string first) second)) klist)))

(define klist->object (pipe klist->alist alist->object))

(define (make-tags expr)
  "(make-tags expression)

   Function that return list structure of code with better syntax then raw LIPS"
  `(h ,(key->string (car expr))
       (alist->object (quasiquote ,@(pair-map (lambda (car cdr)
                                                (cons (cons (key->string car)
                                                            (list 'unquote cdr))))
                                              (cadr expr))))
      ,(if (not (null? (cddr expr)))
           (if (and (pair? (caddr expr)) (let ((s (caaddr expr)))
                                           (and (symbol? s) (eq? s 'list))))
               `(list->array (list ,@(map make-tags (cdaddr expr))))
               (caddr expr)))))


(define-macro (with-tags expr)
  "(with-tags expression)

   Macro that evalute LIPS shorter code for hyperapp"
  (make-tags expr))

;;example macro output:
;;
;;(define (view state actions)
;;  (h "div" (make-empty-object)
;;     (list->array (list
;;                   (h "h1" (make-empty-object) (value (cdr (assoc 'count (. state "counter")))))
;;                   (h "button" (klist->object `(:onclick ,(lambda () (--> actions (down 1))))) "-")
;;                   (h "button" (klist->object `(:onclick ,(lambda () (--> actions (up 1))))) "+")))))
;;for code:
;;
;;(define (view state actions)
;;  (with-tags (:div ()
;;                   (list (:h1 () (value (cdr (assoc 'count (. state "counter")))))
;;                         (:button (:onclick (lambda () (--> actions (down 1)))) "-")
;;                         (:button (:onclick (lambda () (--> actions (up 1)))) "+")))))

(define-macro (global name)
  `(set-obj! window ,(symbol->string name) ,name))
